#ifndef __DISSECT_ICL8_H__
#define __DISSECT_ICL8_H__

// Mostly generated from a script called Tigra Color Picker at http://www.nobleresearch.com/admin/js/colour_palette/picker.js
//
// Note: the above script's generation of positions 216 through 255 was incorrect. Those 40 values should be
// descending gradients of R, G, B, and grayscale with ten steps each. The script was generating 14 steps each.
//
// Some other bug with it was causing 0x000000 to be at position 215 instead of position 255 and that was manually rearranged.
// A screenshot of the Mac OS system palette from http://www.columbia.edu/itc/visualarts/r4110/f2000/week06/06_03_Color_palettes.pdf
// was helpful to figure out what was wrong. The delightful comment block below is lest we forget.

uint8_t macPalette[256][3] = {
	{0xFF,0xFF,0xFF}, {0xFF,0xFF,0xCC}, {0xFF,0xFF,0x99}, {0xFF,0xFF,0x66}, {0xFF,0xFF,0x33}, {0xFF,0xFF,0x00}, {0xFF,0xCC,0xFF}, {0xFF,0xCC,0xCC}, 
	{0xFF,0xCC,0x99}, {0xFF,0xCC,0x66}, {0xFF,0xCC,0x33}, {0xFF,0xCC,0x00}, {0xFF,0x99,0xFF}, {0xFF,0x99,0xCC}, {0xFF,0x99,0x99}, {0xFF,0x99,0x66}, 
	{0xFF,0x99,0x33}, {0xFF,0x99,0x00}, {0xFF,0x66,0xFF}, {0xFF,0x66,0xCC}, {0xFF,0x66,0x99}, {0xFF,0x66,0x66}, {0xFF,0x66,0x33}, {0xFF,0x66,0x00}, 
	{0xFF,0x33,0xFF}, {0xFF,0x33,0xCC}, {0xFF,0x33,0x99}, {0xFF,0x33,0x66}, {0xFF,0x33,0x33}, {0xFF,0x33,0x00}, {0xFF,0x00,0xFF}, {0xFF,0x00,0xCC}, 
	{0xFF,0x00,0x99}, {0xFF,0x00,0x66}, {0xFF,0x00,0x33}, {0xFF,0x00,0x00}, {0xCC,0xFF,0xFF}, {0xCC,0xFF,0xCC}, {0xCC,0xFF,0x99}, {0xCC,0xFF,0x66}, 
	{0xCC,0xFF,0x33}, {0xCC,0xFF,0x00}, {0xCC,0xCC,0xFF}, {0xCC,0xCC,0xCC}, {0xCC,0xCC,0x99}, {0xCC,0xCC,0x66}, {0xCC,0xCC,0x33}, {0xCC,0xCC,0x00}, 
	{0xCC,0x99,0xFF}, {0xCC,0x99,0xCC}, {0xCC,0x99,0x99}, {0xCC,0x99,0x66}, {0xCC,0x99,0x33}, {0xCC,0x99,0x00}, {0xCC,0x66,0xFF}, {0xCC,0x66,0xCC}, 
	{0xCC,0x66,0x99}, {0xCC,0x66,0x66}, {0xCC,0x66,0x33}, {0xCC,0x66,0x00}, {0xCC,0x33,0xFF}, {0xCC,0x33,0xCC}, {0xCC,0x33,0x99}, {0xCC,0x33,0x66}, 
	{0xCC,0x33,0x33}, {0xCC,0x33,0x00}, {0xCC,0x00,0xFF}, {0xCC,0x00,0xCC}, {0xCC,0x00,0x99}, {0xCC,0x00,0x66}, {0xCC,0x00,0x33}, {0xCC,0x00,0x00}, 
	{0x99,0xFF,0xFF}, {0x99,0xFF,0xCC}, {0x99,0xFF,0x99}, {0x99,0xFF,0x66}, {0x99,0xFF,0x33}, {0x99,0xFF,0x00}, {0x99,0xCC,0xFF}, {0x99,0xCC,0xCC}, 
	{0x99,0xCC,0x99}, {0x99,0xCC,0x66}, {0x99,0xCC,0x33}, {0x99,0xCC,0x00}, {0x99,0x99,0xFF}, {0x99,0x99,0xCC}, {0x99,0x99,0x99}, {0x99,0x99,0x66}, 
	{0x99,0x99,0x33}, {0x99,0x99,0x00}, {0x99,0x66,0xFF}, {0x99,0x66,0xCC}, {0x99,0x66,0x99}, {0x99,0x66,0x66}, {0x99,0x66,0x33}, {0x99,0x66,0x00}, 
	{0x99,0x33,0xFF}, {0x99,0x33,0xCC}, {0x99,0x33,0x99}, {0x99,0x33,0x66}, {0x99,0x33,0x33}, {0x99,0x33,0x00}, {0x99,0x00,0xFF}, {0x99,0x00,0xCC}, 
	{0x99,0x00,0x99}, {0x99,0x00,0x66}, {0x99,0x00,0x33}, {0x99,0x00,0x00}, {0x66,0xFF,0xFF}, {0x66,0xFF,0xCC}, {0x66,0xFF,0x99}, {0x66,0xFF,0x66}, 
	{0x66,0xFF,0x33}, {0x66,0xFF,0x00}, {0x66,0xCC,0xFF}, {0x66,0xCC,0xCC}, {0x66,0xCC,0x99}, {0x66,0xCC,0x66}, {0x66,0xCC,0x33}, {0x66,0xCC,0x00}, 
	{0x66,0x99,0xFF}, {0x66,0x99,0xCC}, {0x66,0x99,0x99}, {0x66,0x99,0x66}, {0x66,0x99,0x33}, {0x66,0x99,0x00}, {0x66,0x66,0xFF}, {0x66,0x66,0xCC}, 
	{0x66,0x66,0x99}, {0x66,0x66,0x66}, {0x66,0x66,0x33}, {0x66,0x66,0x00}, {0x66,0x33,0xFF}, {0x66,0x33,0xCC}, {0x66,0x33,0x99}, {0x66,0x33,0x66}, 
	{0x66,0x33,0x33}, {0x66,0x33,0x00}, {0x66,0x00,0xFF}, {0x66,0x00,0xCC}, {0x66,0x00,0x99}, {0x66,0x00,0x66}, {0x66,0x00,0x33}, {0x66,0x00,0x00}, 
	{0x33,0xFF,0xFF}, {0x33,0xFF,0xCC}, {0x33,0xFF,0x99}, {0x33,0xFF,0x66}, {0x33,0xFF,0x33}, {0x33,0xFF,0x00}, {0x33,0xCC,0xFF}, {0x33,0xCC,0xCC}, 
	{0x33,0xCC,0x99}, {0x33,0xCC,0x66}, {0x33,0xCC,0x33}, {0x33,0xCC,0x00}, {0x33,0x99,0xFF}, {0x33,0x99,0xCC}, {0x33,0x99,0x99}, {0x33,0x99,0x66}, 
	{0x33,0x99,0x33}, {0x33,0x99,0x00}, {0x33,0x66,0xFF}, {0x33,0x66,0xCC}, {0x33,0x66,0x99}, {0x33,0x66,0x66}, {0x33,0x66,0x33}, {0x33,0x66,0x00}, 
	{0x33,0x33,0xFF}, {0x33,0x33,0xCC}, {0x33,0x33,0x99}, {0x33,0x33,0x66}, {0x33,0x33,0x33}, {0x33,0x33,0x00}, {0x33,0x00,0xFF}, {0x33,0x00,0xCC}, 
	{0x33,0x00,0x99}, {0x33,0x00,0x66}, {0x33,0x00,0x33}, {0x33,0x00,0x00}, {0x00,0xFF,0xFF}, {0x00,0xFF,0xCC}, {0x00,0xFF,0x99}, {0x00,0xFF,0x66}, 
	{0x00,0xFF,0x33}, {0x00,0xFF,0x00}, {0x00,0xCC,0xFF}, {0x00,0xCC,0xCC}, {0x00,0xCC,0x99}, {0x00,0xCC,0x66}, {0x00,0xCC,0x33}, {0x00,0xCC,0x00}, 
	{0x00,0x99,0xFF}, {0x00,0x99,0xCC}, {0x00,0x99,0x99}, {0x00,0x99,0x66}, {0x00,0x99,0x33}, {0x00,0x99,0x00}, {0x00,0x66,0xFF}, {0x00,0x66,0xCC}, 
	{0x00,0x66,0x99}, {0x00,0x66,0x66}, {0x00,0x66,0x33}, {0x00,0x66,0x00}, {0x00,0x33,0xFF}, {0x00,0x33,0xCC}, {0x00,0x33,0x99}, {0x00,0x33,0x66}, 
	{0x00,0x33,0x33}, {0x00,0x33,0x00}, {0x00,0x00,0xFF}, {0x00,0x00,0xCC}, {0x00,0x00,0x99}, {0x00,0x00,0x66}, {0x00,0x00,0x33}, /* Full black is here in the websafe palette, */
    {0xE7,0x00,0x00}, {0xCF,0x00,0x00}, {0xB7,0x00,0x00}, {0x9F,0x00,0x00}, {0x87,0x00,0x00}, {0x6F,0x00,0x00}, {0x57,0x00,0x00}, {0x3F,0x00,0x00}, /* but on the MacOS system  */
	{0x27,0x00,0x00}, {0x0F,0x00,0x00}, {0x00,0xE7,0x00}, {0x00,0xCF,0x00}, {0x00,0xB7,0x00}, {0x00,0x9F,0x00}, {0x00,0x87,0x00}, {0x00,0x6F,0x00}, /* palette it's down here.  */
	{0x00,0x57,0x00}, {0x00,0x3F,0x00}, {0x00,0x27,0x00}, {0x00,0x0F,0x00}, {0x00,0x00,0xE7}, {0x00,0x00,0xCF}, {0x00,0x00,0xB7}, {0x00,0x00,0x9F}, /*    No, further down.     */ 
	{0x00,0x00,0x87}, {0x00,0x00,0x6F}, {0x00,0x00,0x57}, {0x00,0x00,0x3F}, {0x00,0x00,0x27}, {0x00,0x00,0x0F}, {0xE7,0xE7,0xE7}, {0xCF,0xCF,0xCF}, /*     Almost there!        */
	{0xB7,0xB7,0xB7}, {0x9F,0x9F,0x9F}, {0x87,0x87,0x87}, {0x6F,0x6F,0x6F}, {0x57,0x57,0x57}, {0x3F,0x3F,0x3F}, {0x27,0x27,0x27}, {0x0F,0x0F,0x0F}, {0x00,0x00,0x00}}; /* Bingo */

#define BITMAP_HEADER_SIZE 12
struct BitmapHeader
{
    uint32_t fileSize;
    uint16_t reserved1;
    uint16_t reserved2;
    uint32_t dataOffset;
};

#define BITMAP_INFO_HEADER_SIZE 40
struct BitmapInfoHeader
{
    uint32_t headerSize;
    uint32_t width;
    uint32_t height;
    uint16_t planes;
    uint16_t bpp;
    uint32_t compression;
    uint32_t bitmapDataSize;
    uint32_t horizontalResolution;
    uint32_t verticalResolution;
    uint32_t paletteCount;
    uint32_t importantColorCount;
};

void ConvertResourceToBitmap(struct Resource* pResource)
{
    uint32_t bitmapSize = 2 + BITMAP_HEADER_SIZE + BITMAP_INFO_HEADER_SIZE + (8 * 32 * 32);
    uint8_t* pBitmapData = malloc(bitmapSize);
  
    uint8_t signature[2] = {0x42, 0x4D};
    memcpy(pBitmapData, &signature, 2);
    struct BitmapHeader header;
    header.fileSize = bitmapSize;
    header.reserved1 = 0;
    header.reserved2 = 0;
    header.dataOffset = 2 + BITMAP_HEADER_SIZE + sizeof(struct BitmapInfoHeader);
    memcpy(pBitmapData + 2, &header, BITMAP_HEADER_SIZE);

    struct BitmapInfoHeader infoHeader;
    infoHeader.headerSize = sizeof(struct BitmapInfoHeader);
    infoHeader.width = 32;
    infoHeader.height = (uint32_t)(-32);
    infoHeader.planes = 1;
    infoHeader.bpp = 24;
    infoHeader.compression = 0;
    infoHeader.bitmapDataSize = 8 * 32 * 32;
    infoHeader.horizontalResolution = 2835; // 72dpi
    infoHeader.verticalResolution = 2835;
    infoHeader.paletteCount = 0;
    infoHeader.importantColorCount = 0;
    memcpy(pBitmapData + 2 + BITMAP_HEADER_SIZE, &infoHeader, sizeof(struct BitmapInfoHeader));

    uint8_t brg[3];
    for (uint32_t i = 0; i < pResource->dataSize; i++)
    {
        uint8_t index = pResource->data[i];
        brg[0] = macPalette[index][2]; brg[1] = macPalette[index][1]; brg[2] = macPalette[index][0];
        memcpy(pBitmapData + header.dataOffset + (i * 3), &brg, 3);
    }

    char* filename = CreateFilename(pResource->name, ".bmp");
    FILE* out = fopen(filename, "wb");
    fwrite(pBitmapData, bitmapSize, 1, out);
    fclose(out);
    ReleaseFilename(filename);
}

void DissectIcl8(struct ResourceType* pResourceType)
{
    for (uint16_t i = 0; i < pResourceType->resourceCount; i++)
    {
        ConvertResourceToBitmap(pResourceType->resources[i]);
    }
}

void DissectICN(struct ResourceType* pResourceType)
{
    // These are 1bpp 32x32 icons so create 8bpp icons from them and pass to the icl8 extractor
    for (uint16_t i = 0; i < pResourceType->resourceCount; i++)
    {
        struct Resource* p8bppIcon = malloc(sizeof(struct Resource));
        memset(p8bppIcon->name, 0, 257);
        memcpy(p8bppIcon->name, pResourceType->resources[i]->name, strlen(pResourceType->resources[i]->name));
        p8bppIcon->dataSize = 4 * pResourceType->resources[i]->dataSize;
        p8bppIcon->data = malloc(p8bppIcon->dataSize);
        uint16_t index = 0;
        for (uint8_t j = 0; j < 128; j++)
        {
            uint8_t data = pResourceType->resources[i]->data[j];
            for (char b = 7; b >= 0; b--)
            {
                p8bppIcon->data[index++] = ((data & (1 << b)) != 0) ? 0x00 : 0xFF;
            }
        }

        ConvertResourceToBitmap(p8bppIcon);
        free(p8bppIcon->data);
        free(p8bppIcon);
    }
}

#endif
